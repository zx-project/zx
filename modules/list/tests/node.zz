using <assert.h>::{ assert }
using <string.h>::{ strcmp }

using zxlist

fn main() -> int {
  {
    new node = zxlist::node::init("hello");
    assert(0 == strcmp("hello", node.value));
    node.destroy();
  }

  {
    new mut list = zxlist::init();
    new nested = zxlist::node::init("hello");
    new node = zxlist::node::init(&nested);
    static_attest(safe(node));

    let value = (zxlist::node::Node *) node.value;
    static_attest(safe(value));
    assert(0 == strcmp("hello", value->value));

    list.push_node(&node);
    assert(&node == list.find(&nested));

    nested.destroy();
    //node.destroy();
    list.destroy();
  }

  {
    new mut list = zxlist::init();
    let start = list.push("start");
    let middle0 = list.push("middle0");
    let middle1 = list.push("middle1");
    let middle2 = list.push("middle2");
    let end = list.push("end");

    static_attest(safe(start));
    static_attest(safe(middle0));
    static_attest(safe(middle1));
    static_attest(safe(middle2));
    static_attest(safe(end));

    assert(start == list.head);
    assert(end == list.tail);

    assert(0 == start->prev);
    assert(middle0 == start->next);

    assert(start == middle0->prev);
    assert(middle1 == middle0->next);

    assert(middle0 == middle1->prev);
    assert(middle2 == middle1->next);

    assert(middle1 == middle2->prev);
    assert(end == middle2->next);

    assert(middle2 == end->prev);
    assert(0 == end->next);

    list.destroy();
  }
  return 0;
}
