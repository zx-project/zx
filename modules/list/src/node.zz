using list::{ FreeNodeFunction, List }

using zxutils as utils

/**
 * Theory used to prove that a list node was ok.
 */
export theory ok(Node node) -> bool;

/**
 * Theory used to prove that a list node was changed.
 */
export theory changed(Node node) -> bool;

/**
 * Theory used to prove that a list node was destroyed.
 */
export theory destroyed(Node node) -> bool;

/**
 * A node structure to contain pointers to a list node's value,
 * containing List structure, and next/prev nodes.
 */
export struct Node {
  void *value;
  List mut *list;
  Node mut *prev;
  Node mut *next;
  bool alloc;
}

/**
 * `Node` constructor. Initializes a `Node` pointer with a value pointer.
 * @example
 *   let node = zxlist::node::init();
 */
export fn init(Node new mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(value)
  model safe(return)
  model !destroyed(*self)
  where safe(self)
{
  static_attest(safe(self));
  static_attest(safe(value));

  self->prev = 0;
  self->next = 0;
  self->value = value;

  static_attest(ok(*self));
  static_attest(!destroyed(*self));

  self->deref();

  static_attest(!destroyed(*self));
  static_attest(ok(*self));

  return self;
}

// noop
fn free_noop(Node mut *node) {
  (void) node;
}

/**
 * Allocates and returns memory for an uninitialized `Node` pointer.
 * Calls `zxutils::memory::alloc()` internally and therefore
 * returns memory that must be free'd.
 * @example
 *  let mut node = zxlist::node::alloc();
 *  zxutils::memory::free(node);
 */
export fn alloc() -> Node mut *
  model safe(return)
  model true == return->alloc
{
  let node = (Node mut *) utils::memory::alloc(sizeof(Node));
  static_attest(safe(node));
  node->alloc = true;
  return node;
}

/**
 * Allocates and initializes a new `Node` pointer.
 * Calls `zxutils::memory::alloc()` internally and therefore
 * returns memory that must be free'd.
 */
export fn create(void *value) -> Node mut *
  model ok(*return)
  model safe(value)
  model safe(return)
  model !destroyed(*node)
{
  static_attest(safe(value));
  let node = init(alloc(), value);
  static_attest(ok(*node));
  static_attest(!destroyed(*node));
  static_attest(safe(node));
  return node;
}

/**
 * Destroys a list node, dereferencing any links, and free any possible
 * resources, including the node itself.
 * @example
 *   let node = list.pop();
 *   node->destroy();
 */
export fn destroy(Node mut *self)
  model safe(self)
  model destroyed(*self)

  where ok(*self)
  where safe(self)
  where !destroyed(*self)
{
  static_attest(safe(free_noop));

  let list = self->list;
  let value = self->value;
  let mut free_impl = (FreeNodeFunction) free_noop;

  if 0 != list {
    static_attest(safe(list));
    if 0 != list->prototype.values.free {
      static_attest(safe(list->prototype.values.free));
      list->prototype.values.free((void mut *) value);
    }
  }

  static_attest(ok(*self));
  static_attest(!destroyed(*self));
  self->deref();

  if self->alloc {
    // use default free if node is orphaned
    free_impl = (FreeNodeFunction) utils::memory::free;

    if 0 != list {
      static_attest(safe(list));
      if 0 != list->prototype.nodes.free {
        static_attest(safe(list->prototype.nodes.free));
        free_impl = list->prototype.nodes.free;
      }
    }
  }

  static_attest(safe(free_impl));
  free_impl(self);
  static_attest(destroyed(*self));
}

/**
 * Detaches node from list and any dereferences links
 * @protected
 */
export fn deref(Node mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where safe(self)
  where !destroyed(*self)
{
  if 0 != self->prev {
    static_attest(safe(self->prev));
    self->prev->next = self->next;
  } else if 0 != self->list {
    static_attest(safe(self->list));
    self->list->head = self->next;
  }

  if 0 != self->next {
    static_attest(safe(self->next));
    self->next->prev = self->prev;
  } else if 0 != self->list {
    static_attest(safe(self->list));
    self->list->tail = self->prev;
  }

  self->list = 0;
  self->next = 0;
  self->prev = 0;

  static_attest(ok(*self));
  static_attest(safe(self));
  static_attest(changed(*self));
  static_attest(!destroyed(*self));

  return self;
}
