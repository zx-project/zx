using list::{ List }

using zxutils as utils

/**
 * A node structure to contain pointers to a list node's value,
 * containing List structure, and next/prev nodes.
 */
export struct Node {
  void *value;
  List mut *list;
  Node mut *prev;
  Node mut *next;
  bool alloc;
}

/**
 * `Node` constructor. Initializes a `Node` pointer with a value pointer.
 * @example
 *   let node = zxlist::node::init();
 */
export fn init(Node new mut *self, void *value) -> Node mut *
  model safe(self)
  model safe(value)
  model safe(return)
{
  static_attest(safe(self));
  static_attest(safe(value));

  self->deref();
  self->prev = 0;
  self->next = 0;
  self->value = value;

  return self;
}

/**
 * Allocates and returns memory for an uninitialized `Node` pointer.
 * Calls `zxutils::memory::alloc()` internally and therefore
 * returns memory that must be free'd.
 * @example
 *  let mut node = zxlist::node::alloc();
 *  zxutils::memory::free(node);
 */
export fn alloc() -> Node mut *
  model safe(return)
  model true == return->alloc
{
  let node = (Node mut *) utils::memory::alloc(sizeof(Node));
  static_attest(safe(node));
  node->alloc = true;
  return node;
}

/**
 * Allocates and initializes a new `Node` pointer.
 * Calls `zxutils::memory::alloc()` internally and therefore
 * returns memory that must be free'd.
 */
export fn create(void *value) -> Node mut *
  model safe(value)
  model safe(return)
{
  return init(alloc(), value);
}

/**
 * Destroys a list node, dereferencing any links, and free any possible
 * resources, including the node itself.
 * @example
 *   let node = list.pop();
 *   node->destroy();
 */
export fn destroy(Node mut *self) {
  let list = self->list;
  let value = self->value;

  self->deref();

  if 0 != list {
    static_attest(safe(list));
    if 0 != list->prototype.values.free {
      static_attest(safe(list->prototype.values.free));
      list->prototype.values.free((void mut *) value);
    }
  }

  if self->alloc {
    if 0 != list {
      static_attest(safe(list));
      if 0 != list->prototype.nodes.free {
        static_attest(safe(list->prototype.nodes.free));
        list->prototype.nodes.free(self);
        return;
      }
    }

    // use default free if node is orphaned
    utils::memory::free(self);
  }
}

/**
 * Detaches node from list and any dereferences links
 * @protected
 */
export fn deref(Node mut *self) -> Node mut * {
  if 0 != self->prev {
    static_attest(safe(self->prev));
    self->prev->next = self->next;
  } else if 0 != self->list {
    static_attest(safe(self->list));
    self->list->head = self->next;
  }

  if 0 != self->next {
    static_attest(safe(self->next));
    self->next->prev = self->prev;
  } else if 0 != self->list {
    static_attest(safe(self->list));
    self->list->tail = self->prev;
  }

  self->list = 0;
  self->next = 0;
  self->prev = 0;
  return self;
}
