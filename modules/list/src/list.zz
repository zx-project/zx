using iterator::{
  make as make_iterator,
  Direction,
  Iterator,

  HEAD,
  TAIL,

  destroyed as iterator_destroyed,
  ok as iterator_ok,
}

using node::{
  make as make_node,
  Node,

  destroyed as node_destroyed,
  ok as node_ok,
}

using zxutils as utils

/**
 * Theory used to prove that a list was ok.
 */
export theory ok(List list) -> bool;

/**
 * Theory used to prove that a list was changed.
 */
export theory changed(List list) -> bool;

/**
 * Theory used to prove that a list was destroyed.
 */
export theory destroyed(List list) -> bool;

/**
 * A compare function used to compare pointers when find a node in a list.
 */
export fntype CompareNodeValueFunction(void *a, void *b) -> bool;

/**
 * A structure prototype of list defaults, such as the iterator direction.
 */
export struct ListDefaults {
  Direction iterator_direction;
  CompareNodeValueFunction node_compare_function;
}

/**
 * A doubly linked list suitable for stack allocation.
 */
export struct List+ {
  Node mut *head;
  Node mut *tail;
  usize length;

  CompareNodeValueFunction compare;
  ListDefaults defaults;
  Node nodes[];
}

/**
 * A static structure of list configuration defaults.
 */
static ListDefaults shared_defaults = ListDefaults {
  iterator_direction: HEAD,
  node_compare_function: default_node_value_compare
};

/**
 * Creates a unlinked node from a given value attached to list.
 * @example
 *   new list = zxlist::make();
 *   let node = list.create_node("hello");
 *   node->destroy();
 */
fn create_node(List+L mut *self, void *value) -> Node mut *
  model safe(value)
  model safe(return)
  model ok(*self)
  where ok(*self)
  where self->length < L
{
  let length = self->length;
  let mut node = (Node mut *) &self->nodes[length];

  make_node(node, value);
  node->list = self;

  static_attest(ok(*self));
  return node;
}

/**
 * The default node value comparator function.
 * @private
 */
fn default_node_value_compare(void *left, void *right) -> bool
  model safe(left)
  model safe(right)
{
  static_attest(safe(left));
  static_attest(safe(right));
  return left == right;
}

/**
 * `List` constructor. Initializes a `List` pointer.
 * @constructor
 * @example
 *   new list = zxlist::make();
 */
export fn make(List+L new mut *self)
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model self->length < L

  where safe(self)
  where L > 0
{
  if 0 != self {
    static_attest(safe(self));
  }

  utils::memory::copy(&self->defaults, &shared_defaults, sizeof(ListDefaults));

  self->length = 0;
  self->compare = self->defaults.node_compare_function;

  static_attest(ok(*self));
  static_attest(!destroyed(*self));
  static_attest(self->length < L);
}

/**
 * Destroys list, active iterators, and any allocated nodes
 * still attached to the list.
 * @example
 *   new list = zxlist::make();
 *   list.destroy();
 */
export fn destroy(List+L mut *self)
  model safe(self)
  model destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let mut it = self->iterator();

  while !it.ended {
    let node = (Node mut *) it.next();
    static_attest(!node_destroyed(*node));
    static_attest(node_ok(*node));
    node->destroy();
  }

  utils::memory::zero(self, sizeof(List));
  static_attest(destroyed(*self));
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the default iterator direction.
 * @example
 *   new list = zxlist::make();
 *   let it = list.iterator();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export fn iterator(List+L mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let defaults = self->defaults;
  let it = self->iterator_with_direction(defaults.iterator_direction);

  attest(self, false);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the "head" direction.
 * @example
 *   new list = zxlist::make();
 *   let it = list.iterator_head();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export inline fn iterator_head(List+L mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let it = self->iterator_with_direction(HEAD);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the "tail" direction.
 * @example
 *   new list = zxlist::make();
 *   let it = list.iterator_tail();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export inline fn iterator_tail(List+t mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let it = self->iterator_with_direction(TAIL);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in a given direction.
 * @example
 *   new list = zxlist::make();
 *   let it = list.iterator_with_direction(zxlist::HEAD);
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export fn iterator_with_direction(List+L mut *self, Direction direction) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  new it = make_iterator(self, direction);
  attest(self, false);
  static_attest(iterator_ok(it));
  return it;
}

/**
 * Pushes a value to the right of the list updating the tail returning the
 * newly created list node.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 */
export fn rpush(List+L mut *self, void *value) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  let mut node = self->create_node(value);

  attest(self, false);
  self->rpush_node(node);

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * Pushes a node with a value to the right of the list updating the tail
 * returning the newly created list node.
 * @example
 *   new list = zxlist::make();
 *   let node = zxlist::node::make("hello")
 *   list.rpush_node(&node);
 */
export fn rpush_node(List+L mut *self, Node mut *node) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;

  static_attest(safe(node));

  if length > 0 && 0 != self->tail {
    static_attest(safe(self->tail));
    node->prev = self->tail;
    node->next = 0;
    self->tail->next = node;
    self->tail = node;
  } else {
    node->prev = 0;
    node->next = 0;
    self->head = node;
    self->tail = node;
  }

  self->length = length + 1;

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Pushes a value to the left of the list updating the head returning the
 * newly created list node.
 * @example
 *   new list = zxlist::make();
 *   list.lpush("world");
 *   list.lpush("hello");
 */
export fn lpush(List+L mut *self, void *value) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  let mut node = self->create_node(value);

  attest(self, false);
  self->lpush_node(node);

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * Pushes a value to the left of the list updating the head returning the
 * newly created list node.
 * @example
 *   new list = zxlist::make();
 *   let node = zxlist::node::make("hello");
 *   list.lpush_node(node);
 */
export fn lpush_node(List+L mut *self, Node mut *node) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;

  static_attest(safe(node));

  if length > 0 && 0 != self->head {
    static_attest(safe(self->head));
    node->next = self->head;
    node->prev = 0;
    self->head->prev = node;
    self->head = node;
  } else {
    node->prev = 0;
    node->next = 0;
    self->head = node;
    self->tail = node;
  }

  self->length = length + 1;

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Pops and returns a node with its value from the right of the list updating
 * the tail. The returned node's memory must be managed by the caller as the
 * list will not free any allocated resources for the returned node as it is
 * dereferenced from the list.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   list.rpop(); // "world"
 */
export fn rpop(List+L mut *self) -> void *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;
  let node = self->tail;

  if length - 1 > 0 && 0 != node {
    static_attest(safe(node));
    static_attest(safe(node->prev));

    self->length = length - 1;
    self->tail = node->prev;
    self->tail->next = 0;
  } else {
    self->length = 0;
    self->tail = 0;
    self->head = 0;
  }

  attest(self, true);

  let value = node->value;
  static_attest(safe(value));

  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  node->deref();
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return value;
}

/**
 * Pops and returns a node with its value from the left of the list updating
 * the head. The returned node's memory must be managed by the caller as the
 * list will not free any allocated resources for the returned node as it is
 * dereferenced from the list.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   list.lpop(); // "hello"
 */
export fn lpop(List+L mut *self) -> void *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;
  let node = self->head;

  if length - 1 > 0 && 0 != node {
    static_attest(safe(node));
    static_attest(safe(node->next));

    self->length = length - 1;
    self->head = node->next;
    self->head->prev = 0;
  } else {
    self->length = 0;
    self->tail = 0;
    self->head = 0;
  }

  attest(self, true);

  let value = node->value;

  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  node->deref();
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  static_attest(safe(value));

  return value;
}

/**
 * Finds and returns a list node that points to a value that matches the given
 * value pointer. A user supplied comparator function can be used by setting
 * `list.prototype.values.compare` to a `CompareNodeValueFunction` type, otherwise
 * simple pointer comparison is used by default.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.find("world"); // node with value "world"
 */
export fn find(List+L mut *self, void *value) -> Node *
  model ok(*self)
  model safe(self)
  model safe(self->compare)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  static_attest(safe(self->compare));

  attest(self, false);
  let mut tail = self->iterator_tail();

  attest(self, false);
  let mut head = self->iterator();

  attest(self, false);

  while !head.ended && !tail.ended {
    let left = head.next();
    let right = tail.next();

    if self->compare(value, left->value) {
      return left;
    }

    if self->compare(value, right->value) {
      return right;
    }
  }

  return 0;
}

/**
 * Finds and returns the list node at a given index.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.at(1); // node with value "world"
 */
export fn at(List+L mut *self, int index) -> Node *
  model ok(*self)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  if (usize) index >= self->length {
    return 0;
  }

  if 0 == self->head && 0 == self->tail {
    return 0;
  }

  let mut it = self->iterator();

  if it.ended {
    return 0;
  }

  let mut node = it.next();
  let mut i = index;

  if index < 0 {
    it.direction = (Direction) TAIL;
    it.node = self->tail;
    i = ~index;
  }

  while !it.ended && i-- > 0 {
    node = it.next();
  }

  attest(self, false);

  if 0 != node {
    static_attest(safe(node));
    static_attest(node_ok(*node));
    static_attest(!node_destroyed(*node));
  }

  return node;
}

/**
 * Finds a list node that points to a given value and removes it from the
 * list.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   list.remove("world");
 *   assert(1 == list.length);
 */
export fn remove(List+L mut *self, void *value)
  model ok(*self)
  model safe(self)
  model safe(value)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = (Node mut *) self->find(value);

  if 0 != node {
    static_attest(safe(node));
    static_attest(node_ok(*node));
    static_attest(!node_destroyed(*node));
    self->remove_node(node);
  }

  attest(self, true);
}

/**
 * Removes a node from the list, destroying it, updating links and list
 * length.
 * @example
 *   new list = zxlist::make();
 *   let node = list.push("hello");
 *   list.remove_node(node);
 */
export fn remove_node(List+L mut *self, Node mut *node)
  model ok(*self)
  model safe(self)
  model safe(node)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where node_ok(*node)
  where !destroyed(*self)
  where !node_destroyed(*node)
{
  attest(self, false);
  let length = self->length;

  static_attest(safe(node));
  static_attest(!node_destroyed(*node));
  static_attest(node_ok(*node));
  node->destroy();
  self->length = length - 1;
  static_attest(node_destroyed(*node));

  attest(self, true);
}

/**
 * Returns a boolean indicating if a list contains a value.
 * @example
 *   new list = zxlist::make();
 *   list.push("hello");
 *   if list.contains("hello") {
 *     list.push("world");
 *   }
 */
export fn contains(List+L mut *self, void *value) -> bool
  model ok(*self)
  model safe(self)
  model safe(value)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->find(value);

  attest(self, false);
  if 0 != node {
    return true;
  } else {
    return false;
  }
}

/**
 * Returns a boolean indicating if a list contains a list node.
 * @example
 *   new list = zxlist::make();
 *   let hello = list.push("hello");
 *   if list.contains_node(hello) {
 *     let world = list.create_node("world");
 *     list.push_node(world);
 *   }
 */
export fn contains_node(List+L mut *self, Node *node) -> bool
  model ok(*self)
  model safe(node)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let mut it = self->iterator();

  attest(self, false);

  while !it.ended {
    let suspect = it.next();
    if node == suspect {
      it.destroy();
      return true;
    }
  }

  return false;
}

/**
 * An alias to `list.rpop()`.
 * @example
 *   new list = zxlist::make();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   list.pop(); // "world"
 */
export fn pop(List+L mut *self) -> void *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let value = self->rpop();
  attest(self, true);
  static_attest(safe(value));
  return value;
}

/**
 * An alias to `list.rpush()`.
 * @example
 *   new list = zxlist::make();
 *   list.push("hello");
 *   list.push("world");
 */
export fn push(List+L mut *self, void *value) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  let node = self->rpush(value);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.rpush_node()`.
 * @example
 *   new list = zxlist::make();
 *   let node = zxlist::node::make("hello")
 *   list.push_node(&node);
 */
export fn push_node(List+L mut *self, Node mut *node) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  self->rpush_node(node);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.lpop()`.
 * @example
 *   new list = zxlist::make();
 *   list.push("hello");
 *   list.push("world");
 *   list.shift(); // "hello"
 */
export fn shift(List+L mut *self) -> void *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let value = self->lpop();
  attest(self, true);
  static_attest(safe(value));
  return value;
}

/**
 * An alias to `list.lpush()`.
 * @example
 *   new list = zxlist::make();
 *   list.unshift("world");
 *   list.unshift("hello");
 */
export fn unshift(List+L mut *self, void *value) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  let node = self->lpush(value);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.lpush_node()`.
 * @example
 *   new list = zxlist::make();
 *   let node = zxlist::node::make("hello");
 *   list.unshift_node(node);
 */
export fn unshift_node(List+L mut *self, Node mut *node) -> Node *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
  where self->length < L
{
  attest(self, false);
  self->lpush_node(node);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * List model state attestations.
 */
export fn attest(List+L mut *self, bool did_change)
  model ok(*self)
  model safe(self)
  model changed(*self)
  model !destroyed(*self)
  model self->length < L
{
  if 0 != self { static_attest(safe(self)); }
  if did_change { static_attest(changed(*self)); }
  static_attest(ok(*self));
  static_attest(!destroyed(*self));
  static_attest(self->length < L);
}
