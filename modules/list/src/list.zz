using iterator::{
  init as init_iterator,
  Direction,
  Iterator,

  HEAD,
  TAIL,

  destroyed as iterator_destroyed,
  ok as iterator_ok,
}

using node::{
  alloc as alloc_node,
  init as init_node,
  Node,

  destroyed as node_destroyed,
  ok as node_ok,
}

using zxutils as utils

/**
 * Theory used to prove that a list was ok.
 */
export theory ok(List list) -> bool;

/**
 * Theory used to prove that a list was changed.
 */
export theory changed(List list) -> bool;

/**
 * Theory used to prove that a list was destroyed.
 */
export theory destroyed(List list) -> bool;

/**
 * A free function used to free the value a node points to. This is a
 * NOP function by default.
 */
export fntype FreeNodeValueFunction(void mut *ptr) -> void;

/**
 * A compare function used to compare pointers when find a node in a list.
 */
export fntype CompareNodeValueFunction(void *a, void *b) -> bool;

/**
 * A function used to allocate a `Node *` pointer.
 */
export fntype AllocateNodeFunction() -> Node mut *;

/**
 * A function used to free an allocated `Node *` pointer.
 */
export fntype FreeNodeFunction(Node mut *node) -> void;

/**
 * A prototype of functions used on list nodes.
 */
struct ListNodePrototype {
  FreeNodeFunction free;
  AllocateNodeFunction alloc;
}

/**
 * A prototype of functions used on list node values.
 */
struct ListNodeValuePrototype {
  FreeNodeValueFunction free;
  CompareNodeValueFunction compare;
}

/**
 * A prototype of functions for list nodes and their values.
 */
export struct ListPrototype {
  ListNodeValuePrototype values;
  ListNodePrototype nodes;
}

/**
 * A structure prototype of list defaults, such as the iterator direction.
 */
export struct ListDefaults {
  Direction iterator_direction;
}

/**
 * A doubly linked list suitable for stack allocation.
 */
export struct List {
  Node mut *head;
  Node mut *tail;
  usize length;

  ListPrototype prototype;
  ListDefaults defaults;
}

/**
 * A static structure of list configuration defaults.
 */
static ListDefaults shared_defaults = ListDefaults {
  iterator_direction: HEAD
};

/**
 * Creates (allocate) a list node and attaches self to list node.
 * @private
 */
fn create_list_node(List mut *self, void *value) -> Node mut *
  model safe(value)
  model safe(return)
  model true == return->alloc
  model safe(self->prototype.nodes.alloc)
  model ok(*self)
  where ok(*self)
{
  if 0 != self->prototype.nodes.alloc {
    static_attest(safe(self->prototype.nodes.alloc));
  }

  let mut node = self->prototype.nodes.alloc();

  static_attest(safe(value));
  static_attest(safe(node));

  init_node(node, value);
  node->list = self;
  node->alloc = true;

  static_attest(ok(*self));

  return node;
}

/**
 * The default free function for every list node.
 * @private
 */
fn default_node_free(Node mut *node)
  model safe(node)
{
  utils::memory::free(node);
}

/**
 * The default free function for every list node.
 * @private
 */
fn default_node_allocate() -> Node mut *
  model safe(return)
  model true == return->alloc
{
  let node = alloc_node();
  static_attest(safe(node));
  return node;
}

/**
 * The default NOP free function for every list node value.
 * @private
 */
fn default_node_value_free(void mut * mut ptr) {
  (void) ptr;
}

/**
 * The default node value comparator function.
 * @private
 */
fn default_node_value_compare(void *left, void *right) -> bool
  model safe(left)
  model safe(right)
{
  static_attest(safe(left));
  static_attest(safe(right));
  return left == right;
}

/**
 * `List` constructor. Initializes a `List` pointer.
 * @constructor
 * @example
 *   new list = zxlist::init();
 */
export fn init(List new mut *self)
  model safe(self)
  model ok(*self)
  model !destroyed(*self)
{
  if 0 != self {
    static_attest(safe(self));
  }

  utils::memory::copy(&self->defaults, &shared_defaults, sizeof(ListDefaults));

  static_attest(ok(*self));
  static_attest(!destroyed(*self));

  // set default prototype functions
  self->set_prototype(ListPrototype {
    nodes: ListNodePrototype {
      free: default_node_free,
      alloc: default_node_allocate,
    },

    values: ListNodeValuePrototype {
      free: default_node_value_free,
      compare: default_node_value_compare,
    }
  });

  static_attest(ok(*self));
  static_attest(!destroyed(*self));
}

/**
 * Extend the prototype of the `List` instance.
 * @example
 *   new list = zxlist::init();
 *   list.set_prototype(ListPrototype {
 *     nodes: ListNodePrototype {
 *       free: node_free_function,
 *       alloc: node_allocate_function,
 *     },
 *
 *     values: ListNodeValuePrototype {
 *       free: node_value_free_function,
 *       compare: node_value_compare_function,
 *     }
 *   })
 */
export fn set_prototype(List require<ok> new mut *self, ListPrototype prototype)
  model safe(self)
  model ok(*self)
  where ok(*self)
  where !destroyed(*self)
{
  if 0 != prototype.nodes.free {
    self->prototype.nodes.free = prototype.nodes.free;
  }

  if 0 != prototype.nodes.alloc {
    self->prototype.nodes.alloc = prototype.nodes.alloc;
  }

  if 0 != prototype.values.free {
    self->prototype.values.free = prototype.values.free;
  }

  if 0 != prototype.values.compare {
    self->prototype.values.compare = prototype.values.compare;
  }

  static_attest(ok(*self));
  static_attest(!destroyed(*self));
}

/**
 * Destroys list, active iterators, and any allocated nodes
 * still attached to the list.
 * @example
 *   new list = zxlist::init();
 *   list.destroy();
 */
export fn destroy(List mut *self)
  model safe(self)
  model destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let mut it = self->iterator();

  while !it.ended {
    let node = it.next();
    static_attest(!node_destroyed(*node));
    static_attest(node_ok(*node));
    node->destroy();
  }

  utils::memory::zero(self, sizeof(List));
  static_attest(destroyed(*self));
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the default iterator direction.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export fn iterator(List mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let defaults = self->defaults;
  let it = self->iterator_with_direction(defaults.iterator_direction);

  attest(self, false);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the "head" direction.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator_head();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export inline fn iterator_head(List mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let it = self->iterator_with_direction(HEAD);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in the "tail" direction.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator_tail();
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export inline fn iterator_tail(List mut *self) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)
  model iterator_ok(return)
  model !iterator_destroyed(return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let it = self->iterator_with_direction(TAIL);
  static_attest(iterator_ok(it));
  static_attest(!iterator_destroyed(it));
  return it;
}

/**
 * Creates and returns a stack allocated iterator for a list instance
 * in a given direction.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator_with_direction(zxlist::HEAD);
 *
 *   while !it.ended {
 *     let node = it.next();
 *   }
 *
 *   it.destroy();
 */
export fn iterator_with_direction(List mut *self, Direction direction) -> Iterator
  model ok(*self)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  new it = init_iterator(self, direction);
  attest(self, false);
  static_attest(iterator_ok(it));
  return it;
}

/**
 * Pushes a value to the right of the list updating the tail returning the
 * newly created list node.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 */
export fn rpush(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let mut node = create_list_node(self, value);

  attest(self, false);
  self->rpush_node(node);

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * Pushes a node with a value to the right of the list updating the tail
 * returning the newly created list node.
 * @example
 *   new list = zxlist::init();
 *   let node = zxlist::node::init("hello")
 *   list.rpush_node(&node);
 */
export fn rpush_node(List mut *self, Node mut *node) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;

  static_attest(safe(node));

  if length > 0 && 0 != self->tail {
    static_attest(safe(self->tail));
    node->prev = self->tail;
    node->next = 0;
    self->tail->next = node;
    self->tail = node;
  } else {
    node->prev = 0;
    node->next = 0;
    self->head = node;
    self->tail = node;
  }

  self->length = length + 1;

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Pushes a value to the left of the list updating the head returning the
 * newly created list node.
 * @example
 *   new list = zxlist::init();
 *   list.lpush("world");
 *   list.lpush("hello");
 */
export fn lpush(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let mut node = create_list_node(self, value);

  attest(self, false);
  self->lpush_node(node);

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * Pushes a value to the left of the list updating the head returning the
 * newly created list node.
 * @example
 *   new list = zxlist::init();
 *   let node = zxlist::node::init("hello");
 *   list.lpush_node(node);
 */
export fn lpush_node(List mut *self, Node mut *node) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;

  static_attest(safe(node));

  if length > 0 && 0 != self->head {
    static_attest(safe(self->head));
    node->next = self->head;
    node->prev = 0;
    self->head->prev = node;
    self->head = node;
  } else {
    node->prev = 0;
    node->next = 0;
    self->head = node;
    self->tail = node;
  }

  self->length = length + 1;

  attest(self, true);

  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Pops and returns a node with its value from the right of the list updating
 * the tail. The returned node's memory must be managed by the caller as the
 * list will not free any allocated resources for the returned node as it is
 * dereferenced from the list.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.rpop(); // node with value "world"
 */
export fn rpop(List mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;
  let node = self->tail;

  if length - 1 > 0 && 0 != node {
    static_attest(safe(node));
    static_attest(safe(node->prev));

    self->length = length - 1;
    self->tail = node->prev;
    self->tail->next = 0;
  } else {
    self->length = 0;
    self->tail = 0;
    self->head = 0;
  }

  attest(self, true);

  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  node->deref();
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Pops and returns a node with its value from the left of the list updating
 * the head. The returned node's memory must be managed by the caller as the
 * list will not free any allocated resources for the returned node as it is
 * dereferenced from the list.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.lpop(); // node with value "hello"
 */
export fn lpop(List mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  let length = self->length;
  let node = self->head;

  if length - 1 > 0 && 0 != node {
    static_attest(safe(node));
    static_attest(safe(node->next));

    self->length = length - 1;
    self->head = node->next;
    self->head->prev = 0;
  } else {
    self->length = 0;
    self->tail = 0;
    self->head = 0;
  }

  attest(self, true);

  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  node->deref();
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));

  return node;
}

/**
 * Finds and returns a list node that points to a value that matches the given
 * value pointer. A user supplied comparator function can be used by setting
 * `list.prototype.values.compare` to a `CompareNodeValueFunction` type, otherwise
 * simple pointer comparison is used by default.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.find("world"); // node with value "world"
 */
export fn find(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(self->prototype.values.compare)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  static_attest(safe(self->prototype.values.compare));
  let compare = self->prototype.values.compare;

  attest(self, false);
  let mut tail = self->iterator_tail();

  attest(self, false);
  let mut head = self->iterator();

  attest(self, false);

  while !head.ended && !tail.ended {
    let left = head.next();
    let right = tail.next();

    if compare(value, left->value) {
      return left;
    }

    if compare(value, right->value) {
      return right;
    }
  }

  return 0;
}

/**
 * Finds and returns the list node at a given index.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.at(1); // node with value "world"
 */
export fn at(List mut *self, int index) -> Node mut *
  model ok(*self)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);

  if (usize) index >= self->length {
    return 0;
  }

  if 0 == self->head && 0 == self->tail {
    return 0;
  }

  let mut it = self->iterator();

  if it.ended {
    return 0;
  }

  let mut node = it.next();
  let mut i = index;

  if index < 0 {
    it.direction = (Direction) TAIL;
    it.node = self->tail;
    i = ~index;
  }

  while !it.ended && i-- > 0 {
    node = it.next();
  }

  attest(self, false);

  if 0 != node {
    static_attest(safe(node));
    static_attest(node_ok(*node));
    static_attest(!node_destroyed(*node));
  }

  return node;
}

/**
 * Finds a list node that points to a given value and removes it from the
 * list, freeing any allocated resources. This function will call
 * `list.prototype.nodes.free()`.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   list.remove("world");
 *   assert(1 == list.length);
 */
export fn remove(List mut *self, void *value)
  model ok(*self)
  model safe(self)
  model safe(value)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let mut node = self->find(value);

  if 0 != node {
    static_attest(safe(node));
    static_attest(node_ok(*node));
    static_attest(!node_destroyed(*node));
    self->remove_node(node);
  }

  attest(self, true);
}

/**
 * Removes a node from the list, destroying it, updating links and list
 * length.
 * @example
 *   new list = zxlist::init();
 *   let node = list.push("hello");
 *   list.remove_node(node);
 */
export fn remove_node(List mut *self, Node mut *node)
  model ok(*self)
  model safe(self)
  model safe(node)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where node_ok(*node)
  where !destroyed(*self)
  where !node_destroyed(*node)
{
  attest(self, false);
  let length = self->length;

  static_attest(safe(node));
  static_attest(!node_destroyed(*node));
  static_attest(node_ok(*node));
  node->destroy();
  self->length = length - 1;
  static_attest(node_destroyed(*node));

  attest(self, true);
}

/**
 * Returns a boolean indicating if a list contains a value.
 * @example
 *   new list = zxlist::init();
 *   list.push("hello");
 *   if list.contains("hello") {
 *     list.push("world");
 *   }
 */
export fn contains(List mut *self, void *value) -> bool
  model ok(*self)
  model safe(self)
  model safe(value)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->find(value);

  attest(self, false);
  if 0 != node {
    return true;
  } else {
    return false;
  }
}

/**
 * Returns a boolean indicating if a list contains a list node.
 * @example
 *   new list = zxlist::init();
 *   let hello = list.push("hello");
 *   if list.contains_node(hello) {
 *     let world = list.create_node("world");
 *     list.push_node(world);
 *   }
 */
export fn contains_node(List mut *self, Node *node) -> bool
  model ok(*self)
  model safe(node)
  model safe(self)
  model !destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let mut it = self->iterator();

  attest(self, false);

  while !it.ended {
    let suspect = it.next();
    if node == suspect {
      it.destroy();
      return true;
    }
  }

  return false;
}

/**
 * An alias to `list.rpop()`.
 * @example
 *   new list = zxlist::init();
 *   list.rpush("hello");
 *   list.rpush("world");
 *   let node = list.pop(); // node with value "world"
 */
export fn pop(List mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->rpop();
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.rpush()`.
 * @example
 *   new list = zxlist::init();
 *   list.push("hello");
 *   list.push("world");
 */
export fn push(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->rpush(value);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.rpush_node()`.
 * @example
 *   new list = zxlist::init();
 *   let node = zxlist::node::init("hello")
 *   list.push_node(&node);
 */
export fn push_node(List mut *self, Node mut *node) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  self->rpush_node(node);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.lpop()`.
 * @example
 *   new list = zxlist::init();
 *   list.push("hello");
 *   list.push("world");
 *   let node = list.shift(); // node with value "hello"
 */
export fn shift(List mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->lpop();
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.lpush()`.
 * @example
 *   new list = zxlist::init();
 *   list.unshift("world");
 *   list.unshift("hello");
 */
export fn unshift(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = self->lpush(value);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * An alias to `list.lpush_node()`.
 * @example
 *   new list = zxlist::init();
 *   let node = zxlist::node::init("hello");
 *   list.unshift_node(node);
 */
export fn unshift_node(List mut *self, Node mut *node) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  self->lpush_node(node);
  attest(self, true);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * Creates a unlinked node from a given value attached to list.
 * @example
 *   new list = zxlist::init();
 *   let node = list.create_node("hello");
 *   node->destroy();
 */
export fn create_node(List mut *self, void *value) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model changed(*self)
  model !destroyed(*self)
  model node_ok(*return)
  model !node_destroyed(*return)

  where ok(*self)
  where !destroyed(*self)
{
  attest(self, false);
  let node = create_list_node(self, value);
  attest(self, false);
  static_attest(safe(node));
  static_attest(node_ok(*node));
  static_attest(!node_destroyed(*node));
  return node;
}

/**
 * List model state attestations.
 */
export fn attest(List mut *self, bool did_change)
  model ok(*self)
  model safe(self)
  model changed(*self)
  model !destroyed(*self)
{
  if 0 != self { static_attest(safe(self)); }
  if did_change { static_attest(changed(*self)); }
  static_attest(ok(*self));
  static_attest(!destroyed(*self));
}
