using list::{ List, MAX_MANAGED_ITERATORS }
using node::{ Node }

using zxutils as utils

/**
 * The list iterator iteration direction.
 */
export enum Direction {
  Head = 0,
  Tail = 1
}

/**
 */
export const int HEAD = Direction::Head;

/**
 */
export const int TAIL = Direction::Tail;

/**
 * An iterator context for a list.
 */
export struct Iterator {
  Direction direction;
  bool ended;
  List mut *list;
  Node mut *node;
}

/**
 */
export struct Pool+ {
  usize length;
  Iterator mut pool[];
}

/**
 * `Iterator` stack constructor with direction from a list.
 */
export fn init(Iterator new mut *self, List mut *list, Direction direction) -> Iterator mut *
  model safe(list)
  model safe(self)
  model safe(return)
{
  static_attest(safe(self));
  static_attest(safe(list));

  self->list = list;
  self->ended = false;
  self->direction = direction;

  switch self->direction {
    Direction::Head => { self->node = list->head; }
    Direction::Tail => { self->node = list->tail; }
  }

  if 0 == self->node {
    self->ended = true;
  }

  return self;
}

/**
 * `Iterator` heap constructor with heap allocation.
 */
export fn create(List mut*list, Direction direction) -> Iterator mut *
  model safe(list)
  model safe(return)
{
  static_attest(list->iterators.length < len(list->iterators.pool));
  let index = list->iterators.length;
  let self = &list->iterators.pool[index];

  list->iterators.length = index + 1;

  static_attest(safe(self));
  static_attest(safe(list));

  init(self, list, direction);

  return self;
}

/**
 * Returns a pointer to the next node in the list.
 */
export fn next(Iterator mut *self) -> Node mut *
  model safe(return)
{
  let node = self->node;

  if 0 != node {
    static_attest(safe(node));
    switch self->direction {
      Direction::Head => { self->node = node->next; }
      Direction::Tail => { self->node = node->prev; }
    }
  }

  if 0 == self->node {
    self->ended = true;
  }

  static_attest(safe(node));
  return node;
}

/**
 * Destroys the iterator, free'ing itself if it was marked
 * as allocated.
 */
export fn destroy(Iterator mut *self) {
  let list = self->list;
  self->list = 0;

  if 0 != list {
    static_attest(safe(list));
    static_attest(list->iterators.length < len(list->iterators.pool));
    for (usize mut i = 0; i < list->iterators.length; ++i) {
      static_attest(safe(&list->iterators.pool[i]));
      if self == &list->iterators.pool[i] {
        utils::memory::zero(&list->iterators.pool[i], sizeof(Iterator));
        return;
      }
    }
  }
}
