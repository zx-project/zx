using list::{ List }
using node::{ Node }

using zxutils as utils

/**
 * Theory used to prove that a list iterator was ok.
 */
export theory ok(Iterator iterator) -> bool;

/**
 * Theory used to prove that a list iterator was changed.
 */
export theory changed(Iterator iterator) -> bool;

/**
 * Theory used to prove that a list iterator was destroyed.
 */
export theory destroyed(Iterator iterator) -> bool;

/**
 * The list iterator iteration direction.
 */
export enum Direction {
  Head = 0,
  Tail = 1
}

/**
 * The `Direction::Head` enum value exported as a
 * constant for better ergonomics.
 */
export const int HEAD = Direction::Head;

/**
 * The `Direction::Tail` enum value exported as a
 * constant for better ergonomics.
 */
export const int TAIL = Direction::Tail;

/**
 * An iterator context for a list.
 */
export struct Iterator {
  Direction direction;
  bool ended;
  List mut *list;
  Node mut *node;
}

/**
 * `Iterator` stack constructor with direction from a list.
 */
export fn init(
  Iterator new mut *self,
  List mut *list,
  Direction direction
) -> Iterator mut *
  model ok(*self)
  model safe(list)
  model safe(self)
  model safe(return)
  model !destroyed(*self)
{
  static_attest(safe(self));
  static_attest(safe(list));

  self->list = list;
  self->ended = false;
  self->direction = direction;

  switch direction {
    Direction::Head => { self->node = list->head; }
    Direction::Tail => { self->node = list->tail; }
  }

  if 0 == self->node {
    self->ended = true;
  }

  static_attest(ok(*self));
  static_attest(!destroyed(*self));

  return self;
}

/**
 * Returns a pointer to the next node in the list.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator();
 *   while !it.ended {
 *     let node = it.next();
 *   }
 */
export fn next(Iterator mut *self) -> Node mut *
  model ok(*self)
  model safe(self)
  model safe(return)
  model safe(return->value)
  model changed(*self)
  model !destroyed(*self)

  where ok(*self)
  where false == self->ended
  where !destroyed(*self)
{
  let node = self->node;

  if 0 != node {
    static_attest(safe(node));
    switch self->direction {
      Direction::Head => { self->node = node->next; }
      Direction::Tail => { self->node = node->prev; }
    }
  }

  if 0 == self->node {
    self->ended = true;
  }

  static_attest(safe(node));
  static_attest(safe(node->value));

  static_attest(ok(*self));
  static_attest(changed(*self));
  static_attest(!destroyed(*self));

  return node;
}

/**
 * Marks the iterator as "ended".
 * @example
 *   new list = zxlist::init();
 *   let mut it = list.iterator();
 *
 *   while !it.ended {
 *     if list.contains(key) {
 *       it.end();
 *     } else {
 *       it.next();
 *    }
 *   }
 *
 *   it.destroy();
 */
export fn end(Iterator mut *self)
  model ok(*self)
  model safe(self)
  model changed(*self)
  //model !destroyed(*self)

  where ok(*self)
  where safe(self)
  where !destroyed(*self)
{
  self->ended = true;
  self->node = 0;

  static_attest(ok(*self));
  static_attest(safe(self));
  static_attest(changed(*self));
  static_attest(!destroyed(*self));
}

/**
 * Destroys the iterator.
 * @example
 *   new list = zxlist::init();
 *   let it = list.iterator();
 *   it.destroy();
 */
export fn destroy(Iterator mut *self)
  model safe(self)
  model destroyed(*self)

  where ok(*self)
  where !destroyed(*self)
{
  static_attest(ok(*self));
  static_attest(!destroyed(*self));

  self->end();
  self->list = 0;

  static_attest(destroyed(*self));
}
