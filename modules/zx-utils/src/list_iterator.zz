using <list/list.h> as native
using <assert.h>::{ assert }

using list_node::{ Node }
using list::{ List, MAX_MANAGED_ITERATORS }
using memory

export enum Direction {
  Head,
  Tail
}

export struct Iterator {
  Direction direction;
  bool ended;
  List mut *list;
  bool alloc;
  native::list_iterator_t mut *internal;
}

export fn init(Iterator new mut *self, List mut *list, Direction direction) {
  let mut iterator_index = MAX_MANAGED_ITERATORS;

  // find first available iterator index
  for (usize mut i = 0; i < MAX_MANAGED_ITERATORS; ++i) {
    if 0 == list->iterators[i] {
      iterator_index = i;
      break;
    }
  }

  assert(iterator_index < MAX_MANAGED_ITERATORS); // cannot allocate list iterator

  self->list = list;
  self->alloc = false;
  static_attest(safe(self->list));

  switch direction {
    Direction::Head => {
      self->internal = native::list_iterator_new(list->internal, native::LIST_HEAD);
    }

    Direction::Tail => {
      self->internal = native::list_iterator_new(list->internal, native::LIST_TAIL);
    }
  }

  static_attest(safe(self));
  static_attest(len(list->iterators) > iterator_index);
  list->iterators[iterator_index] = self;
}

export fn create(List mut*list, Direction direction) -> Iterator mut *
  model safe(list)
  model safe(return)
{
  static_attest(safe(list));
  let it = (Iterator mut *) memory::alloc(sizeof(Iterator));
  static_attest(safe(it));
  init(it, list, direction);
  it->alloc = true;
  return it;
}

export fn next(Iterator mut *self) -> Node mut * {
  static_attest(safe(self->internal));
  native::list_node_t *item = native::list_iterator_next(self->internal);

  unsafe {
    if 0 == self->internal->next {
      self->ended = true;
    }
  }

  static_attest(safe(item));
  if 0 != item {
    unsafe { return item->val; }
  }

  return 0;
}

export fn destroy(Iterator mut *self) {
  if 0 != self->list {
    static_attest(safe(self->list));
    for (usize mut i = 0; i < MAX_MANAGED_ITERATORS; ++i) {
      if self == self->list->iterators[i] {
        self->list->iterators[i] = 0;
      }
    }
  }

  native::list_iterator_destroy(self->internal);
  self->internal = 0;

  if self->alloc {
    memory::free(self);
  }
}
